# Mini-Lisp 解释器

这是北京大学《软件设计实践》课程的大作业：用 C++ 实现的简易 Mini-Lisp 语言解释器。

关于 Mini-Lisp 语言，请参考[Mini-Lisp 编程语言规范](https://pku-software.github.io/mini-lisp-spec/)。

项目仍在开发中。

## REPL 模式

命令行参数：不传入任何命令行参数。

解释器以“读取-求值-打印”循环的方式解释执行输入的命令。

## 文件模式

命令行参数：Mini-Lisp 源代码文件名。

解释器解释执行源文件。

## 交互模式

命令行参数：选项 `-i`，Mini-Lisp 源代码文件名。`-i` 应位于文件名之前。

解释器先解释执行源文件，之后进入 REPL 模式。

## 高级特性

### 多行输入

可以将一个表达式拆成几行输入。当上一行的表达式输入还未结束时，解释器的提示符会变成 `... `。 

### 自动缩进

当你多行输入表达式时，解释器会解析已输入的表达式，提供自动缩进功能。

自动缩进按照“美观形式”的规则，即自动缩进到与当前表达式的首个非过程参数对齐的位置。

示例：

```scheme
>>> (define (triple x) (+ x    ; 此处换行
...                       x    ; 自动缩进
...                       x)
...         )
>>> double
```

### 更多的内置过程

`(max x ...)`

返回值：参数中的最大值。


`(min x ...)`

返回值：参数中的最小值。


`(list-ref ls x)`

返回值：列表 `ls` 索引为 `x` 的元素（索引自 0 开始）


`(list-tail ls x)`

返回值：列表 `ls` 的以索引为 `x` 的元素起始的子列表


`(number->string x)`

`(string->number str)`

`string` 与 `number` 之间的类型转换。


`(set! x y)`

将 `x` 的值设定为 `y`   返回值：`y`


`(for-each proc list)`

将 `proc` 作用于 `list` 的每一个元素    返回值：空表




    
